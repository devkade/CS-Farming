# **3.8 Array Allocation and Access**

- C 언어에서 배열은 스칼라 데이터를 더 큰 데이터 타입으로 묶는 한 가지 수단이다.
- C언어에서는 배열을 특히 단순하게 구현하며, 이로 인해 배열을 기계어로 변환하는 과정도 비교적 간단하다.
- C 언어의 특이한 점 중 하나는 배열 내의 요소에 대한 포인터를 생성하고, 이러한 포인터를 사용하여 산술연산이 가능하다. 이러한 포인터 연산은 기계어에서 주소계산으로 변환된다.

## 3.8.1 Basic Principles

- 데이터 타입 T와 정수 상수 N에 대해 다음과 같은 선언을 고려해보자 ex) int A[3];
    
          T A[N];
    
- 시작하는 위치를 $x_A$라고 했을 때, 이 선언은 두 가지 효과를 가진다.
    1. 자료형 T의 크기를 L이라 할 때, 메모리 상에서 L*N 바이트의 연속된 영역이 할당된다.
    2. 새로운 식별자 A에 의해 배열의 시작 주소 x_A에 접근할 수 있다.
- 배열 요소는 정수 인덱스 0≤i<N을 사용해 접근할 수 있다.
- 배열의 i번째 요소는 주소 $x_A+L*i$에 저장된다.

---

** 배열 선언 예시 

```c
char A[12];
char *B[8];
int C[6];
double *D[5];
```

이 선언에 의해 생성되는 배열의 속성은 다음과 같다.

| 배열 | 요소 크기 (바이트) | 총 크기 (바이트) | 시작 주소 | iii번째 요소의 주소 |
| --- | --- | --- | --- | --- |
| A | 1 | 12 | xA​ | xA+i |
| B | 8 | 64 | xB | xB+8⋅i |
| C | 4 | 24 | xC​ | xC+4⋅i |
| D | 8 | 40 | xD | xD+8⋅i |

---

x86-64에서의 배열 접근

- E가 int 타입의 배열이라 할 때, 배열 E의 주소가 레지스터 %rdx에, 인덱스 i가 레지스터 %rcx에 저장되어있다고 가정.

```
movl (%rdx,%rcx,4),%eax
```

→ 주소 $x_E+4*i$를 계산하여, 해당 메모리 위치의 값을 읽어 레지스터 %eax에 복사

## 3.8.2 Pointer Arithmetic

- C 언어는 포인터 산술 연산이 가능하다.
- 이 연산의 결과는 포인터가 참조하는 데이터 타입의 크기에 따라 scaling된다.

ex) 

- 포인터 p가 데이터 타입 T를 참조하고, p의 값이 $x_p$라면, p+i는 $x_p + L*i$가 된다.(L은 T의 크기)

---

### The unary operations  ‘&’, ‘*’

- C 언어의 단항 연산자 &,*는 포인터 생성 및 역참조(dereferencing)을 수행한다.
    - &Expr : object를 나타내는 표현식 Expr에 대해, &Expr는 해당 객체의 주소를 가리키는 포인터를 변환한다.
    - AExpr : 주소를 나타내는 표현식 AExpr(=&Expr)에 대해, *AExpr는 해당 주소에 저장된 값을 반환한다.
    - 즉 Expr = *&Expr이다.

---

### Array Subscripting Operation

- 배열 첨자 연산(the array subscripting operation)인 ‘[ ]’은 배열과 포인터 모두에 적용할 수 있고, 동일하게 작동
    - int A[] 이고,  int *ptr = A라고 할 때
    - A[i] = *(A+i) → 배열의 i번째 요소의 주소를 계산 후, 해당 메모리 위치를 참조하여 값을 가져옴
    - ptr[i] = *(ptr + i ) → ptr은 배열의 첫 번째 요소를 가리키므로,  동일하게 산술연산이 가능하다.

---

### 포인터와 배열 예제

- 정수 배열 E의 시작 주소와 정수 인덱스 i가 각각 레지스터 %rdx, %rcx에 저장되어 있다고 가정
- 다음은 E를 사용하는 표현식과 이에 대한 어셈블리 코드

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181336](https://github.com/user-attachments/assets/376abc3c-2181-4cf3-b25b-192926301016)

- data type에 따라 사용하는 레지스터와 연산이 달라진다.
    - 레지스터
        1. 정수 : %eax 레지스터(32bit)
        2. 포인터: %rax 레지스터(64bit)
        - 이는 x86-64 아키텍처가 효율적으로 설계한 것.
    - 연산
        1. 정수 : movl (4byte 연산)
        2. 포인터 : leaq (8byte 연산)
- 마지막 예제는 동일한 데이터 구조 내에서 두 포인터 차이를 계산할 수 있음을 보여준다.
    - 결과 데이터 타입은 long, 값은 두 주소의 차이를 데이터 타입의 크기로 나눈 값이다.
    - $(x_E+4i - x_E) / 4 = i$

## 3.8.3 Nested Arrays

- 배열의 일반적인 할당 및 참조 원리는 배열의 배열을 생성할 때도 동일하게 적용
    
        int A[5][3];
    ---

        typedef int row3_t[3]; 
        row3_t A[5];
    
- 두 선언은 동일한 배열을 나타낸다.
- 배열의 요소는 행 우선(row-major order)방식으로 메모리에 저장된다.
    - 배열의 첫 번째 행의 모든 요소 A[0]가 메모리에 먼저 저장되고, 그 다음 두 번째 행의 모든 요소 A[1]이 저장된다.
    - A는 3개의 int로 구성된 5개의 요소를 가진 배열이다.

---

**다차원 배열의 요소 접근**

- 접근하고자 하는 요소의 offset을 계산하여, 배열의 시작 주소를 기준으로 offset만큼 이동하는 mov 명령어를 사용한다.
- offset 계산
    - T D[R][C]; 와 같은 배열이 선언되었을 때, 배열의 요소 D[i][j]는
    - &D[i][j] = $x_D+L*(C*i+j)$

***example***

- int A[5][3]; 에서 x_A, i, j 가 각각 레지스터 %rdi, %rsi, %rdx에 저장되어 있다고 가정
- 다음은 배열 요소 A[i][j]를 레지스터 %eax에 복사하는 코드이다.

```
leaq (%rsi,%rsi,2), %rax     # 3i 계산
leaq (%rdi,%rax,4), %rax     # x_A + 12i 계산
movl (%rax,%rdx,4), %eax     # M[x_A + 12i + 4j]에서 읽어오기
```

- 이 코드는 배열 요소의 주소를 다음과 같이 계산
    
     $x_A + 12i + 4j = x_A +4*(3u=i+j)$
    

## 3.8.4 Fixed-Size Arrays

- C 컴파일러는 고정 크기의 다차원 배열에서 동작하는 코드에 대해 많은 최적화를 수행가능
- 이 단원에서는 최적화 수준을 flag -O1로 설정했을 때 gcc가 수행하는 최적화를 보여준다.
    - flag -O1 : 기본 최적화로 간단한 최적화 작업만 수행하여 약간의 성능 향상을 제공하는 최적화 수준
- 다음과 같이 16*16 크기의 정수 배열을 선언했다고 가정

```c
#define N 16
typedef int fix_matrix[N][N];
```

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181401](https://github.com/user-attachments/assets/495ba64f-6672-4e75-b43d-3c7c19024a53)

- Figure 3.37 (a)는 배열 A와 B의 행렬 곱에서  (i,k)요소를 계산하는 코드이다.
- 이는 배열 A의 i번째 행과 배열 B의 k번째 열의 내적을 계산하는 것으로 아래식을 사용한다.
    
    $\Sigma_{0<=j<N} a_{i,j}*b_{j,k}$
    

- 3.37(b)는 위의 C코드를 gcc가 최적화한 코드이다. 위 코드는 다음과 같은 최적화가 이루어졌다.
    1. 정수 인덱스 제거 : 정수 인덱스 j가 제거됨
    2. 배열 참조를 포인터 역참조로 변환
        1. 포인터 Aptr : 배열 A의 i번째 행의 요소를 가리킨다.
        2. 포인터 Bptr: 배열 B의 k번째 열의 요소를 가리킨다.
        3. 포인터 Bend: 루프 종료 시점을 나타내며, 배열 B의 k번째 열의 n+1번째 요소를 가리킨다.

---

생성된 어셈블리 코드

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181409](https://github.com/user-attachments/assets/204a31c3-e1a6-4841-ad79-902adfcacd76)

이 코드에서는 아래와 같은 레지스터를 사용한다.

- %eax : 결과값 저장
- %rdi: 포인터 Aptr
- %rcx : 포인터 Bptr
- %rsi : 포인터 Bend(배열 B의 루프 종료 위치)

## 3.8.5 Variable-Size Arrays

- 역사적으로 C언어는 첫번째 차원을 제외한 배열 크기를 컴파일 시점에 결정할 수 있는 다차원 배열만을 지원했다.
    - 가변 크기 배열을 malloc 또는 calloc 같은 함수를 사용하여 배열을 직접 동작으로 할당해야 한다.
- ISO C99 표준에서는 배열이 할당될 때 배열 크기를 결정할 수 있는 기능을 추가하였다.

```c
int A[expr1][expr2];
```

- expr는 로컬 변수나 함수의 인자를 사용할 수 있으며, 배열의 크기는 선언이 실행되는 시점에서 expr1와 expr2를 평가(evaluate)하여 결정된다.

---

***example***

**C언어에서 가변 크기 배열**

```c
int var_ele(long n, int A[n][n], long i, long j) {
    return A[i][j];
}
```

→ 여기서 매개변수 n은 배열 A[n][n]보다 앞에 위치해야 한다.

- 이는 함수가 배열 크기를 계산할 수 있도록 하기 위함이다.

gcc가 위 함수에 대해서 생성한 코드이다.

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181424](https://github.com/user-attachments/assets/6b465e2d-fad3-4f0d-a4c1-e7ed5c1477e9)

- 이 코드에서 배열 요소 i,j의 주소를 다음과 같이 계산한다.
    - $x_A+4(n*i)+4j$
- 이 주소 계산은 고정 크기 배열(3.8.3)과 유사하지만, 다음의 차이점이 있다.
    1. 매개변수 n이 추가되면서 레지스터 사용이 변경
    2. n*i를 계산하기 위해 곱셈 명령어(line2)가 사용.

---

**loop에서 가변 크기 배열 참조**

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181430](https://github.com/user-attachments/assets/c9f270a8-fd0a-49b4-8ac3-41bac15a08a6)

![%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-11-19_181437](https://github.com/user-attachments/assets/e706ce30-593f-4c70-863e-e77daae514bf)

**컴파일러의 최적화**

1. scale된 값 4n : 레지스터 %r9에 저장되어 Bptr+=n 연산을 처리한다.
2. 값 n : 레지스터 %rdi에 저장되어 루프 종료 조건 확인에 사용된다.
- 포인터 연산의 스케이링 특성 덕분에 C 코드에서는 이러한 두 값의 필요서이 명시적으로 드러나지 않습니다.

**Conclusion**

- 최적화를 활성화하면, gcc는 다차원 배열 요소를 참조하는 동안 발생하는 패턴을 인식하고, 이를 활용해 곱셈 명령어를 피하는 코드를 생성할 수 있다.
- 컴파일러가 생성한 코드가 포인터 기반코드(3.37)인지 배열 기반 코드(3.38)인지에 관계없이, 이러한 최적화 프로그램 성능을 향상시킨다.